/* automatically generated by rust-bindgen */

pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __XSI_VISIBLE: u32 = 700;
pub const __BSD_VISIBLE: u32 = 1;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __EXT1_VISIBLE: u32 = 1;
pub const __WCHAR_MIN: u32 = 0;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const _SIG_WORDS: u32 = 4;
pub const _SIG_MAXSIG: u32 = 128;
pub const FD_SETSIZE: u32 = 1024;
pub const MDT_DEPEND: u32 = 1;
pub const MDT_MODULE: u32 = 2;
pub const MDT_VERSION: u32 = 3;
pub const MDT_PNP_INFO: u32 = 4;
pub const MDT_STRUCT_VERSION: u32 = 1;
pub const MDT_SETNAME: &'static [u8; 16usize] = b"modmetadata_set\0";
pub const MAXMODNAME: u32 = 32;
pub const BSD: u32 = 199506;
pub const BSD4_3: u32 = 1;
pub const BSD4_4: u32 = 1;
pub const __FreeBSD_version: u32 = 1300088;
pub const P_OSREL_SIGWAIT: u32 = 700000;
pub const P_OSREL_SIGSEGV: u32 = 700004;
pub const P_OSREL_MAP_ANON: u32 = 800104;
pub const P_OSREL_MAP_FSTRICT: u32 = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: u32 = 1100077;
pub const P_OSREL_MAP_GUARD: u32 = 1200035;
pub const P_OSREL_WRFSBASE: u32 = 1200041;
pub const P_OSREL_CK_CYLGRP: u32 = 1200046;
pub const P_OSREL_VMTOTAL64: u32 = 1200054;
pub const P_OSREL_CK_SUPERBLOCK: u32 = 1300000;
pub const P_OSREL_CK_INODE: u32 = 1300005;
pub const P_OSREL_POWERPC_NEW_AUX_ARGS: u32 = 1300070;
pub const ARG_MAX: u32 = 524288;
pub const CHILD_MAX: u32 = 40;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 1023;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const MAXCOMLEN: u32 = 19;
pub const MAXINTERP: u32 = 1024;
pub const MAXLOGNAME: u32 = 33;
pub const MAXUPRC: u32 = 40;
pub const NCARGS: u32 = 524288;
pub const NGROUPS: u32 = 1024;
pub const NOFILE: u32 = 64;
pub const NOGROUP: u32 = 65535;
pub const MAXHOSTNAMELEN: u32 = 256;
pub const SPECNAMELEN: u32 = 255;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const EOPNOTSUPP: u32 = 45;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EIDRM: u32 = 82;
pub const ENOMSG: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const ECANCELED: u32 = 85;
pub const EILSEQ: u32 = 86;
pub const ENOATTR: u32 = 87;
pub const EDOOFUS: u32 = 88;
pub const EBADMSG: u32 = 89;
pub const EMULTIHOP: u32 = 90;
pub const ENOLINK: u32 = 91;
pub const EPROTO: u32 = 92;
pub const ENOTCAPABLE: u32 = 93;
pub const ECAPMODE: u32 = 94;
pub const ENOTRECOVERABLE: u32 = 95;
pub const EOWNERDEAD: u32 = 96;
pub const EINTEGRITY: u32 = 97;
pub const ELAST: u32 = 97;
pub const ERESTART: i32 = -1;
pub const EJUSTRETURN: i32 = -2;
pub const ENOIOCTL: i32 = -3;
pub const EDIRIOCTL: i32 = -4;
pub const ERELOOKUP: i32 = -5;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_VIRTUAL: u32 = 1;
pub const CLOCK_PROF: u32 = 2;
pub const CLOCK_MONOTONIC: u32 = 4;
pub const CLOCK_UPTIME: u32 = 5;
pub const CLOCK_UPTIME_PRECISE: u32 = 7;
pub const CLOCK_UPTIME_FAST: u32 = 8;
pub const CLOCK_REALTIME_PRECISE: u32 = 9;
pub const CLOCK_REALTIME_FAST: u32 = 10;
pub const CLOCK_MONOTONIC_PRECISE: u32 = 11;
pub const CLOCK_MONOTONIC_FAST: u32 = 12;
pub const CLOCK_SECOND: u32 = 13;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 15;
pub const TIMER_RELTIME: u32 = 0;
pub const TIMER_ABSTIME: u32 = 1;
pub const CPUCLOCK_WHICH_PID: u32 = 0;
pub const CPUCLOCK_WHICH_TID: u32 = 1;
pub const TC_DEFAULTPERC: u32 = 5;
pub const PRI_ITHD: u32 = 1;
pub const PRI_REALTIME: u32 = 2;
pub const PRI_TIMESHARE: u32 = 3;
pub const PRI_IDLE: u32 = 4;
pub const PRI_FIFO_BIT: u32 = 8;
pub const PRI_FIFO: u32 = 10;
pub const PRI_MIN: u32 = 0;
pub const PRI_MAX: u32 = 255;
pub const PRI_MIN_ITHD: u32 = 0;
pub const PI_REALTIME: u32 = 0;
pub const PI_AV: u32 = 4;
pub const PI_NET: u32 = 8;
pub const PI_DISK: u32 = 12;
pub const PI_TTY: u32 = 16;
pub const PI_DULL: u32 = 20;
pub const PI_SOFT: u32 = 24;
pub const PRI_MIN_REALTIME: u32 = 48;
pub const PRI_MIN_KERN: u32 = 80;
pub const PSWP: u32 = 80;
pub const PVM: u32 = 84;
pub const PINOD: u32 = 88;
pub const PRIBIO: u32 = 92;
pub const PVFS: u32 = 96;
pub const PZERO: u32 = 100;
pub const PSOCK: u32 = 104;
pub const PWAIT: u32 = 108;
pub const PLOCK: u32 = 112;
pub const PPAUSE: u32 = 116;
pub const PRI_MIN_TIMESHARE: u32 = 120;
pub const PUSER: u32 = 120;
pub const PRI_MIN_IDLE: u32 = 224;
pub const PRI_MAX_IDLE: u32 = 255;
pub const PRI_USER: i32 = -2;
pub const PRI_UNCHANGED: i32 = -1;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const STACKALIGNBYTES: u32 = 15;
pub const MACHINE: &'static [u8; 6usize] = b"arm64\0";
pub const MACHINE_ARCH: &'static [u8; 8usize] = b"aarch64\0";
pub const MACHINE_ARCH32: &'static [u8; 6usize] = b"armv7\0";
pub const MAXCPU: u32 = 1;
pub const MAXMEMDOM: u32 = 2;
pub const CACHE_LINE_SHIFT: u32 = 7;
pub const CACHE_LINE_SIZE: u32 = 128;
pub const PAGE_SHIFT: u32 = 12;
pub const PAGE_SIZE: u32 = 4096;
pub const PAGE_MASK: u32 = 4095;
pub const PAGE_SHIFT_16K: u32 = 14;
pub const PAGE_SIZE_16K: u32 = 16384;
pub const PAGE_MASK_16K: u32 = 16383;
pub const PAGE_SHIFT_64K: u32 = 16;
pub const PAGE_SIZE_64K: u32 = 65536;
pub const PAGE_MASK_64K: u32 = 65535;
pub const MAXPAGESIZES: u32 = 2;
pub const KSTACK_PAGES: u32 = 4;
pub const KSTACK_GUARD_PAGES: u32 = 1;
pub const PCPU_PAGES: u32 = 1;
pub const VM_BCACHE_SIZE_MAX: u32 = 419430400;
pub const DEV_BSHIFT: u32 = 9;
pub const DEV_BSIZE: u32 = 512;
pub const BLKDEV_IOSIZE: u32 = 4096;
pub const DFLTPHYS: u32 = 65536;
pub const MAXPHYS: u32 = 131072;
pub const MAXDUMPPGS: u32 = 16;
pub const MSIZE: u32 = 256;
pub const MCLSHIFT: u32 = 11;
pub const MCLBYTES: u32 = 2048;
pub const MJUMPAGESIZE: u32 = 4096;
pub const MJUM9BYTES: u32 = 9216;
pub const MJUM16BYTES: u32 = 16384;
pub const PRIMASK: u32 = 255;
pub const PCATCH: u32 = 256;
pub const PDROP: u32 = 512;
pub const NZERO: u32 = 0;
pub const NBBY: u32 = 8;
pub const CMASK: u32 = 18;
pub const MAXBSIZE: u32 = 65536;
pub const MAXBCACHEBUF: u32 = 65536;
pub const BKVASIZE: u32 = 16384;
pub const BKVAMASK: u32 = 16383;
pub const MAXPATHLEN: u32 = 1024;
pub const MAXSYMLINKS: u32 = 32;
pub const FSHIFT: u32 = 11;
pub const FSCALE: u32 = 2048;
pub const INSN_SIZE: u32 = 4;
pub const MRS_MASK: u32 = 4293918720;
pub const MRS_VALUE: u32 = 3576692736;
pub const MRS_Op0_SHIFT: u32 = 19;
pub const MRS_Op0_MASK: u32 = 524288;
pub const MRS_Op1_SHIFT: u32 = 16;
pub const MRS_Op1_MASK: u32 = 458752;
pub const MRS_CRn_SHIFT: u32 = 12;
pub const MRS_CRn_MASK: u32 = 61440;
pub const MRS_CRm_SHIFT: u32 = 8;
pub const MRS_CRm_MASK: u32 = 3840;
pub const MRS_Op2_SHIFT: u32 = 5;
pub const MRS_Op2_MASK: u32 = 224;
pub const MRS_Rt_SHIFT: u32 = 0;
pub const MRS_Rt_MASK: u32 = 31;
pub const CNTHCTL_EVNTI_MASK: u32 = 240;
pub const CNTHCTL_EVNTDIR: u32 = 8;
pub const CNTHCTL_EVNTEN: u32 = 4;
pub const CNTHCTL_EL1PCEN: u32 = 2;
pub const CNTHCTL_EL1PCTEN: u32 = 1;
pub const CNTP_CTL_ENABLE: u32 = 1;
pub const CNTP_CTL_IMASK: u32 = 2;
pub const CNTP_CTL_ISTATUS: u32 = 4;
pub const CPACR_FPEN_MASK: u32 = 3145728;
pub const CPACR_FPEN_TRAP_ALL1: u32 = 0;
pub const CPACR_FPEN_TRAP_EL0: u32 = 1048576;
pub const CPACR_FPEN_TRAP_ALL2: u32 = 2097152;
pub const CPACR_FPEN_TRAP_NONE: u32 = 3145728;
pub const CPACR_TTA: u32 = 268435456;
pub const CTR_RES1: u32 = 2147483648;
pub const CTR_TminLine_SHIFT: u32 = 32;
pub const CTR_DIC_SHIFT: u32 = 29;
pub const CTR_DIC_MASK: u32 = 536870912;
pub const CTR_IDC_SHIFT: u32 = 28;
pub const CTR_IDC_MASK: u32 = 268435456;
pub const CTR_CWG_SHIFT: u32 = 24;
pub const CTR_CWG_MASK: u32 = 251658240;
pub const CTR_ERG_SHIFT: u32 = 20;
pub const CTR_ERG_MASK: u32 = 15728640;
pub const CTR_DLINE_SHIFT: u32 = 16;
pub const CTR_DLINE_MASK: u32 = 983040;
pub const CTR_L1IP_SHIFT: u32 = 14;
pub const CTR_L1IP_MASK: u32 = 49152;
pub const CTR_L1IP_VPIPT: u32 = 0;
pub const CTR_L1IP_AIVIVT: u32 = 16384;
pub const CTR_L1IP_VIPT: u32 = 32768;
pub const CTR_L1IP_PIPT: u32 = 49152;
pub const CTR_ILINE_SHIFT: u32 = 0;
pub const CTR_ILINE_MASK: u32 = 15;
pub const DAIF_D_MASKED: u32 = 512;
pub const DAIF_A_MASKED: u32 = 256;
pub const DAIF_I_MASKED: u32 = 128;
pub const DAIF_F_MASKED: u32 = 64;
pub const DCZID_DZP: u32 = 16;
pub const DCZID_BS_SHIFT: u32 = 0;
pub const DCZID_BS_MASK: u32 = 15;
pub const ESR_ELx_ISS_MASK: u32 = 33554431;
pub const ISS_INSN_FnV: u32 = 1024;
pub const ISS_INSN_EA: u32 = 512;
pub const ISS_INSN_S1PTW: u32 = 128;
pub const ISS_INSN_IFSC_MASK: u32 = 31;
pub const ISS_MSR_DIR_SHIFT: u32 = 0;
pub const ISS_MSR_DIR: u32 = 1;
pub const ISS_MSR_Rt_SHIFT: u32 = 5;
pub const ISS_MSR_Rt_MASK: u32 = 992;
pub const ISS_MSR_CRm_SHIFT: u32 = 1;
pub const ISS_MSR_CRm_MASK: u32 = 30;
pub const ISS_MSR_CRn_SHIFT: u32 = 10;
pub const ISS_MSR_CRn_MASK: u32 = 15360;
pub const ISS_MSR_OP1_SHIFT: u32 = 14;
pub const ISS_MSR_OP1_MASK: u32 = 114688;
pub const ISS_MSR_OP2_SHIFT: u32 = 17;
pub const ISS_MSR_OP2_MASK: u32 = 917504;
pub const ISS_MSR_OP0_SHIFT: u32 = 20;
pub const ISS_MSR_OP0_MASK: u32 = 3145728;
pub const ISS_MSR_REG_MASK: u32 = 4193310;
pub const ISS_DATA_ISV_SHIFT: u32 = 24;
pub const ISS_DATA_ISV: u32 = 16777216;
pub const ISS_DATA_SAS_SHIFT: u32 = 22;
pub const ISS_DATA_SAS_MASK: u32 = 12582912;
pub const ISS_DATA_SSE_SHIFT: u32 = 21;
pub const ISS_DATA_SSE: u32 = 2097152;
pub const ISS_DATA_SRT_SHIFT: u32 = 16;
pub const ISS_DATA_SRT_MASK: u32 = 2031616;
pub const ISS_DATA_SF: u32 = 32768;
pub const ISS_DATA_AR: u32 = 16384;
pub const ISS_DATA_FnV: u32 = 1024;
pub const ISS_DATA_EA: u32 = 512;
pub const ISS_DATA_CM: u32 = 256;
pub const ISS_DATA_S1PTW: u32 = 128;
pub const ISS_DATA_WnR_SHIFT: u32 = 6;
pub const ISS_DATA_WnR: u32 = 64;
pub const ISS_DATA_DFSC_MASK: u32 = 63;
pub const ISS_DATA_DFSC_ASF_L0: u32 = 0;
pub const ISS_DATA_DFSC_ASF_L1: u32 = 1;
pub const ISS_DATA_DFSC_ASF_L2: u32 = 2;
pub const ISS_DATA_DFSC_ASF_L3: u32 = 3;
pub const ISS_DATA_DFSC_TF_L0: u32 = 4;
pub const ISS_DATA_DFSC_TF_L1: u32 = 5;
pub const ISS_DATA_DFSC_TF_L2: u32 = 6;
pub const ISS_DATA_DFSC_TF_L3: u32 = 7;
pub const ISS_DATA_DFSC_AFF_L1: u32 = 9;
pub const ISS_DATA_DFSC_AFF_L2: u32 = 10;
pub const ISS_DATA_DFSC_AFF_L3: u32 = 11;
pub const ISS_DATA_DFSC_PF_L1: u32 = 13;
pub const ISS_DATA_DFSC_PF_L2: u32 = 14;
pub const ISS_DATA_DFSC_PF_L3: u32 = 15;
pub const ISS_DATA_DFSC_EXT: u32 = 16;
pub const ISS_DATA_DFSC_EXT_L0: u32 = 20;
pub const ISS_DATA_DFSC_EXT_L1: u32 = 21;
pub const ISS_DATA_DFSC_EXT_L2: u32 = 22;
pub const ISS_DATA_DFSC_EXT_L3: u32 = 23;
pub const ISS_DATA_DFSC_ECC: u32 = 24;
pub const ISS_DATA_DFSC_ECC_L0: u32 = 28;
pub const ISS_DATA_DFSC_ECC_L1: u32 = 29;
pub const ISS_DATA_DFSC_ECC_L2: u32 = 30;
pub const ISS_DATA_DFSC_ECC_L3: u32 = 31;
pub const ISS_DATA_DFSC_ALIGN: u32 = 33;
pub const ISS_DATA_DFSC_TLB_CONFLICT: u32 = 48;
pub const ESR_ELx_IL: u32 = 33554432;
pub const ESR_ELx_EC_SHIFT: u32 = 26;
pub const ESR_ELx_EC_MASK: u32 = 4227858432;
pub const EXCP_UNKNOWN: u32 = 0;
pub const EXCP_TRAP_WFI_WFE: u32 = 1;
pub const EXCP_FP_SIMD: u32 = 7;
pub const EXCP_ILL_STATE: u32 = 14;
pub const EXCP_SVC32: u32 = 17;
pub const EXCP_SVC64: u32 = 21;
pub const EXCP_HVC: u32 = 22;
pub const EXCP_MSR: u32 = 24;
pub const EXCP_INSN_ABORT_L: u32 = 32;
pub const EXCP_INSN_ABORT: u32 = 33;
pub const EXCP_PC_ALIGN: u32 = 34;
pub const EXCP_DATA_ABORT_L: u32 = 36;
pub const EXCP_DATA_ABORT: u32 = 37;
pub const EXCP_SP_ALIGN: u32 = 38;
pub const EXCP_TRAP_FP: u32 = 44;
pub const EXCP_SERROR: u32 = 47;
pub const EXCP_BRKPT_EL0: u32 = 48;
pub const EXCP_SOFTSTP_EL0: u32 = 50;
pub const EXCP_SOFTSTP_EL1: u32 = 51;
pub const EXCP_WATCHPT_EL1: u32 = 53;
pub const EXCP_BRK: u32 = 60;
pub const ICC_CTLR_EL1_EOIMODE: u32 = 2;
pub const ICC_IAR1_EL1_SPUR: u32 = 1023;
pub const ICC_IGRPEN0_EL1_EN: u32 = 1;
pub const ICC_PMR_EL1_PRIO_MASK: u32 = 255;
pub const ICC_SGI1R_EL1_TL_MASK: u32 = 65535;
pub const ICC_SGI1R_EL1_AFF1_SHIFT: u32 = 16;
pub const ICC_SGI1R_EL1_SGIID_SHIFT: u32 = 24;
pub const ICC_SGI1R_EL1_AFF2_SHIFT: u32 = 32;
pub const ICC_SGI1R_EL1_AFF3_SHIFT: u32 = 48;
pub const ICC_SGI1R_EL1_SGIID_MASK: u32 = 15;
pub const ICC_SGI1R_EL1_IRM: u64 = 1099511627776;
pub const ICC_SRE_EL1_SRE: u32 = 1;
pub const ID_AA64DFR0_DebugVer_SHIFT: u32 = 0;
pub const ID_AA64DFR0_TraceVer_SHIFT: u32 = 4;
pub const ID_AA64DFR0_PMUVer_SHIFT: u32 = 8;
pub const ID_AA64DFR0_BRPs_SHIFT: u32 = 12;
pub const ID_AA64DFR0_WRPs_SHIFT: u32 = 20;
pub const ID_AA64DFR0_CTX_CMPs_SHIFT: u32 = 28;
pub const ID_AA64DFR0_PMSVer_SHIFT: u32 = 32;
pub const ID_AA64ISAR0_AES_SHIFT: u32 = 4;
pub const ID_AA64ISAR0_SHA1_SHIFT: u32 = 8;
pub const ID_AA64ISAR0_SHA2_SHIFT: u32 = 12;
pub const ID_AA64ISAR0_CRC32_SHIFT: u32 = 16;
pub const ID_AA64ISAR0_Atomic_SHIFT: u32 = 20;
pub const ID_AA64ISAR0_RDM_SHIFT: u32 = 28;
pub const ID_AA64ISAR0_SHA3_SHIFT: u32 = 32;
pub const ID_AA64ISAR0_SM3_SHIFT: u32 = 36;
pub const ID_AA64ISAR0_SM4_SHIFT: u32 = 40;
pub const ID_AA64ISAR0_DP_SHIFT: u32 = 44;
pub const ID_AA64ISAR1_DPB_SHIFT: u32 = 0;
pub const ID_AA64ISAR1_APA_SHIFT: u32 = 4;
pub const ID_AA64ISAR1_API_SHIFT: u32 = 8;
pub const ID_AA64ISAR1_JSCVT_SHIFT: u32 = 12;
pub const ID_AA64ISAR1_FCMA_SHIFT: u32 = 16;
pub const ID_AA64ISAR1_LRCPC_SHIFT: u32 = 20;
pub const ID_AA64ISAR1_GPA_SHIFT: u32 = 24;
pub const ID_AA64ISAR1_GPI_SHIFT: u32 = 28;
pub const ID_AA64MMFR0_PARange_SHIFT: u32 = 0;
pub const ID_AA64MMFR0_ASIDBits_SHIFT: u32 = 4;
pub const ID_AA64MMFR0_BigEnd_SHIFT: u32 = 8;
pub const ID_AA64MMFR0_SNSMem_SHIFT: u32 = 12;
pub const ID_AA64MMFR0_BigEndEL0_SHIFT: u32 = 16;
pub const ID_AA64MMFR0_TGran16_SHIFT: u32 = 20;
pub const ID_AA64MMFR0_TGran64_SHIFT: u32 = 24;
pub const ID_AA64MMFR0_TGran4_SHIFT: u32 = 28;
pub const ID_AA64MMFR1_HAFDBS_SHIFT: u32 = 0;
pub const ID_AA64MMFR1_VMIDBits_SHIFT: u32 = 4;
pub const ID_AA64MMFR1_VH_SHIFT: u32 = 8;
pub const ID_AA64MMFR1_HPDS_SHIFT: u32 = 12;
pub const ID_AA64MMFR1_LO_SHIFT: u32 = 16;
pub const ID_AA64MMFR1_PAN_SHIFT: u32 = 20;
pub const ID_AA64MMFR1_SpecSEI_SHIFT: u32 = 24;
pub const ID_AA64MMFR1_XNX_SHIFT: u32 = 28;
pub const ID_AA64MMFR2_CnP_SHIFT: u32 = 0;
pub const ID_AA64MMFR2_UAO_SHIFT: u32 = 4;
pub const ID_AA64MMFR2_LSM_SHIFT: u32 = 8;
pub const ID_AA64MMFR2_IESB_SHIFT: u32 = 12;
pub const ID_AA64MMFR2_VARange_SHIFT: u32 = 16;
pub const ID_AA64MMFR2_CCIDX_SHIFT: u32 = 20;
pub const ID_AA64MMFR2_NV_SHIFT: u32 = 24;
pub const ID_AA64PFR0_EL0_SHIFT: u32 = 0;
pub const ID_AA64PFR0_EL1_SHIFT: u32 = 4;
pub const ID_AA64PFR0_EL2_SHIFT: u32 = 8;
pub const ID_AA64PFR0_EL3_SHIFT: u32 = 12;
pub const ID_AA64PFR0_FP_SHIFT: u32 = 16;
pub const ID_AA64PFR0_AdvSIMD_SHIFT: u32 = 20;
pub const ID_AA64PFR0_GIC_BITS: u32 = 4;
pub const ID_AA64PFR0_GIC_SHIFT: u32 = 24;
pub const ID_AA64PFR0_RAS_SHIFT: u32 = 28;
pub const ID_AA64PFR0_SVE_SHIFT: u32 = 32;
pub const ID_AA64PFR0_SEL2_SHIFT: u32 = 36;
pub const ID_AA64PFR0_MPAM_SHIFT: u32 = 40;
pub const ID_AA64PFR0_AMU_SHIFT: u32 = 44;
pub const ID_AA64PFR0_DIT_SHIFT: u32 = 48;
pub const ID_AA64PFR0_CSV2_SHIFT: u32 = 56;
pub const ID_AA64PFR0_CSV3_SHIFT: u32 = 60;
pub const ID_AA64PFR1_BT_SHIFT: u32 = 0;
pub const ID_AA64PFR1_SSBS_SHIFT: u32 = 4;
pub const ID_AA64PFR1_MTE_SHIFT: u32 = 8;
pub const ID_AA64PFR1_RAS_frac_SHIFT: u32 = 12;
pub const MAIR_DEVICE_nGnRnE: u32 = 0;
pub const MAIR_NORMAL_NC: u32 = 68;
pub const MAIR_NORMAL_WT: u32 = 187;
pub const MAIR_NORMAL_WB: u32 = 255;
pub const PAR_F_SHIFT: u32 = 0;
pub const PAR_F: u32 = 1;
pub const PAR_SH_SHIFT: u32 = 7;
pub const PAR_SH_MASK: u32 = 384;
pub const PAR_NS_SHIFT: u32 = 9;
pub const PAR_NS_MASK: u32 = 1536;
pub const PAR_PA_SHIFT: u32 = 12;
pub const PAR_PA_MASK: u64 = 281474976706560;
pub const PAR_ATTR_SHIFT: u32 = 56;
pub const PAR_ATTR_MASK: i64 = -72057594037927936;
pub const PAR_FST_SHIFT: u32 = 1;
pub const PAR_FST_MASK: u32 = 126;
pub const PAR_PTW_SHIFT: u32 = 8;
pub const PAR_PTW_MASK: u32 = 256;
pub const PAR_S_SHIFT: u32 = 9;
pub const PAR_S_MASK: u32 = 512;
pub const SCTLR_RES0: u32 = 3357680704;
pub const SCTLR_RES1: u32 = 818939904;
pub const SCTLR_M: u32 = 1;
pub const SCTLR_A: u32 = 2;
pub const SCTLR_C: u32 = 4;
pub const SCTLR_SA: u32 = 8;
pub const SCTLR_SA0: u32 = 16;
pub const SCTLR_CP15BEN: u32 = 32;
pub const SCTLR_ITD: u32 = 128;
pub const SCTLR_SED: u32 = 256;
pub const SCTLR_UMA: u32 = 512;
pub const SCTLR_I: u32 = 4096;
pub const SCTLR_EnDB: u32 = 8192;
pub const SCTLR_DZE: u32 = 16384;
pub const SCTLR_UCT: u32 = 32768;
pub const SCTLR_nTWI: u32 = 65536;
pub const SCTLR_nTWE: u32 = 262144;
pub const SCTLR_WXN: u32 = 524288;
pub const SCTLR_IESB: u32 = 2097152;
pub const SCTLR_SPAN: u32 = 8388608;
pub const SCTLR_EOE: u32 = 16777216;
pub const SCTLR_EE: u32 = 33554432;
pub const SCTLR_UCI: u32 = 67108864;
pub const SCTLR_EnDA: u32 = 134217728;
pub const SCTLR_nTLSMD: u32 = 268435456;
pub const SCTLR_LSMAOE: u32 = 536870912;
pub const SCTLR_EnIB: u32 = 1073741824;
pub const SCTLR_EnIA: u32 = 2147483648;
pub const PSR_M_EL0t: u32 = 0;
pub const PSR_M_EL1t: u32 = 4;
pub const PSR_M_EL1h: u32 = 5;
pub const PSR_M_EL2t: u32 = 8;
pub const PSR_M_EL2h: u32 = 9;
pub const PSR_M_64: u32 = 0;
pub const PSR_M_32: u32 = 16;
pub const PSR_M_MASK: u32 = 15;
pub const PSR_T: u32 = 32;
pub const PSR_AARCH32: u32 = 16;
pub const PSR_F: u32 = 64;
pub const PSR_I: u32 = 128;
pub const PSR_A: u32 = 256;
pub const PSR_D: u32 = 512;
pub const PSR_DAIF: u32 = 960;
pub const PSR_IL: u32 = 1048576;
pub const PSR_SS: u32 = 2097152;
pub const PSR_V: u32 = 268435456;
pub const PSR_C: u32 = 536870912;
pub const PSR_Z: u32 = 1073741824;
pub const PSR_N: u32 = 2147483648;
pub const PSR_FLAGS: u32 = 4026531840;
pub const TCR_HD_SHIFT: u32 = 40;
pub const TCR_HD: u64 = 1099511627776;
pub const TCR_HA_SHIFT: u32 = 39;
pub const TCR_HA: u64 = 549755813888;
pub const TCR_ASID_SHIFT: u32 = 36;
pub const TCR_ASID_WIDTH: u32 = 1;
pub const TCR_ASID_16: u64 = 68719476736;
pub const TCR_IPS_SHIFT: u32 = 32;
pub const TCR_IPS_WIDTH: u32 = 3;
pub const TCR_IPS_32BIT: u32 = 0;
pub const TCR_IPS_36BIT: u64 = 4294967296;
pub const TCR_IPS_40BIT: u64 = 8589934592;
pub const TCR_IPS_42BIT: u64 = 12884901888;
pub const TCR_IPS_44BIT: u64 = 17179869184;
pub const TCR_IPS_48BIT: u64 = 21474836480;
pub const TCR_TG1_SHIFT: u32 = 30;
pub const TCR_TG1_16K: u32 = 1073741824;
pub const TCR_TG1_4K: u32 = 2147483648;
pub const TCR_TG1_64K: u32 = 3221225472;
pub const TCR_TG0_MASK: u32 = 49152;
pub const TCR_SH1_SHIFT: u32 = 28;
pub const TCR_SH1_IS: u32 = 805306368;
pub const TCR_ORGN1_SHIFT: u32 = 26;
pub const TCR_ORGN1_WBWA: u32 = 67108864;
pub const TCR_IRGN1_SHIFT: u32 = 24;
pub const TCR_IRGN1_WBWA: u32 = 16777216;
pub const TCR_A1_SHIFT: u32 = 22;
pub const TCR_A1: u32 = 4194304;
pub const TCR_SH0_SHIFT: u32 = 12;
pub const TCR_SH0_IS: u32 = 12288;
pub const TCR_ORGN0_SHIFT: u32 = 10;
pub const TCR_ORGN0_WBWA: u32 = 1024;
pub const TCR_IRGN0_SHIFT: u32 = 8;
pub const TCR_IRGN0_WBWA: u32 = 256;
pub const TCR_CACHE_ATTRS: u32 = 83887360;
pub const TCR_SMP_ATTRS: u32 = 0;
pub const TCR_T1SZ_SHIFT: u32 = 16;
pub const TCR_T0SZ_SHIFT: u32 = 0;
pub const TCR_T0SZ_MASK: u32 = 63;
pub const DBG_SPSR_SS: u32 = 2097152;
pub const DBG_MDSCR_SS: u32 = 1;
pub const DBG_MDSCR_KDE: u32 = 8192;
pub const DBG_MDSCR_MDE: u32 = 32768;
pub const PMCR_E: u32 = 1;
pub const PMCR_P: u32 = 2;
pub const PMCR_C: u32 = 4;
pub const PMCR_D: u32 = 8;
pub const PMCR_X: u32 = 16;
pub const PMCR_DP: u32 = 32;
pub const PMCR_LC: u32 = 64;
pub const PMCR_IMP_SHIFT: u32 = 24;
pub const PMCR_IMP_MASK: u32 = 4278190080;
pub const PMCR_IDCODE_SHIFT: u32 = 16;
pub const PMCR_IDCODE_MASK: u32 = 16711680;
pub const PMCR_IDCODE_CORTEX_A57: u32 = 1;
pub const PMCR_IDCODE_CORTEX_A72: u32 = 2;
pub const PMCR_IDCODE_CORTEX_A53: u32 = 3;
pub const PMCR_N_SHIFT: u32 = 11;
pub const PMCR_N_MASK: u32 = 63488;
pub const CALLOUT_LOCAL_ALLOC: u32 = 1;
pub const CALLOUT_ACTIVE: u32 = 2;
pub const CALLOUT_PENDING: u32 = 4;
pub const CALLOUT_MPSAFE: u32 = 8;
pub const CALLOUT_RETURNUNLOCKED: u32 = 16;
pub const CALLOUT_SHAREDLOCK: u32 = 32;
pub const CALLOUT_DFRMIGRATION: u32 = 64;
pub const CALLOUT_PROCESSED: u32 = 128;
pub const CALLOUT_DIRECT: u32 = 256;
pub const C_DIRECT_EXEC: u32 = 1;
pub const C_PRELBITS: u32 = 7;
pub const C_PRELRANGE: u32 = 127;
pub const C_HARDCLOCK: u32 = 256;
pub const C_ABSOLUTE: u32 = 512;
pub const C_PRECALC: u32 = 1024;
pub const C_CATCH: u32 = 2048;
pub const CS_DRAIN: u32 = 1;
pub const CS_EXECUTING: u32 = 2;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -2147483648;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 2147483647;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 4294967295;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const __WORDSIZE: u32 = 64;
pub const WCHAR_MIN: u32 = 0;
pub const RSIZE_MAX: i32 = -1;
pub const CPU_SETSIZE: u32 = 1;
pub const CPU_MAXSIZE: u32 = 256;
pub const LOCK_DEBUG: u32 = 1;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_THREAD: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIMIT_SBSIZE: u32 = 9;
pub const RLIMIT_VMEM: u32 = 10;
pub const RLIMIT_AS: u32 = 10;
pub const RLIMIT_NPTS: u32 = 11;
pub const RLIMIT_SWAP: u32 = 12;
pub const RLIMIT_KQUEUES: u32 = 13;
pub const RLIMIT_UMTXP: u32 = 14;
pub const RLIM_NLIMITS: u32 = 15;
pub const CP_USER: u32 = 0;
pub const CP_NICE: u32 = 1;
pub const CP_SYS: u32 = 2;
pub const CP_INTR: u32 = 3;
pub const CP_IDLE: u32 = 4;
pub const CPUSTATES: u32 = 5;
pub const __CHAR_BIT: u32 = 8;
pub const __SCHAR_MAX: u32 = 127;
pub const __SCHAR_MIN: i32 = -128;
pub const __UCHAR_MAX: u32 = 255;
pub const __USHRT_MAX: u32 = 65535;
pub const __SHRT_MAX: u32 = 32767;
pub const __SHRT_MIN: i32 = -32768;
pub const __UINT_MAX: u32 = 4294967295;
pub const __INT_MAX: u32 = 2147483647;
pub const __INT_MIN: i32 = -2147483648;
pub const __ULONG_MAX: i32 = -1;
pub const __LONG_MAX: u64 = 9223372036854775807;
pub const __LONG_MIN: i64 = -9223372036854775808;
pub const __ULLONG_MAX: i32 = -1;
pub const __LLONG_MAX: u64 = 9223372036854775807;
pub const __LLONG_MIN: i64 = -9223372036854775808;
pub const __SSIZE_MAX: u64 = 9223372036854775807;
pub const __SIZE_T_MAX: i32 = -1;
pub const __OFF_MAX: u64 = 9223372036854775807;
pub const __OFF_MIN: i64 = -9223372036854775808;
pub const __UQUAD_MAX: i32 = -1;
pub const __QUAD_MAX: u64 = 9223372036854775807;
pub const __QUAD_MIN: i64 = -9223372036854775808;
pub const __LONG_BIT: u32 = 64;
pub const __WORD_BIT: u32 = 32;
pub const __MINSIGSTKSZ: u32 = 4096;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const SIGTHR: u32 = 32;
pub const SIGLWP: u32 = 32;
pub const SIGLIBRT: u32 = 33;
pub const SIGRTMIN: u32 = 65;
pub const SIGRTMAX: u32 = 126;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_KEVENT: u32 = 3;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_OOMERR: u32 = 100;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_PKUERR: u32 = 100;
pub const FPE_INTOVF: u32 = 1;
pub const FPE_INTDIV: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_DTRACE: u32 = 3;
pub const TRAP_CAP: u32 = 4;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const NSIG: u32 = 32;
pub const SI_NOINFO: u32 = 0;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SI_KERNEL: u32 = 65542;
pub const SI_LWP: u32 = 65543;
pub const SI_UNDEFINED: u32 = 0;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 4096;
pub const SIGSTKSZ: u32 = 36864;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const _MC_FP_VALID: u32 = 1;
pub const UCF_SWAPPED: u32 = 1;
pub const GET_MC_CLEAR_RET: u32 = 1;
pub const CPU_AFF0_MASK: u32 = 255;
pub const CPU_AFF1_MASK: u32 = 65280;
pub const CPU_AFF2_MASK: u32 = 16711680;
pub const CPU_AFF3_MASK: u64 = 1095216660480;
pub const CPU_AFF_MASK: u64 = 1095233437695;
pub const CPU_IMPL_ARM: u32 = 65;
pub const CPU_IMPL_BROADCOM: u32 = 66;
pub const CPU_IMPL_CAVIUM: u32 = 67;
pub const CPU_IMPL_DEC: u32 = 68;
pub const CPU_IMPL_INFINEON: u32 = 73;
pub const CPU_IMPL_FREESCALE: u32 = 77;
pub const CPU_IMPL_NVIDIA: u32 = 78;
pub const CPU_IMPL_APM: u32 = 80;
pub const CPU_IMPL_QUALCOMM: u32 = 81;
pub const CPU_IMPL_MARVELL: u32 = 86;
pub const CPU_IMPL_INTEL: u32 = 105;
pub const CPU_PART_FOUNDATION: u32 = 3328;
pub const CPU_PART_CORTEX_A53: u32 = 3331;
pub const CPU_PART_CORTEX_A35: u32 = 3332;
pub const CPU_PART_CORTEX_A55: u32 = 3333;
pub const CPU_PART_CORTEX_A65: u32 = 3334;
pub const CPU_PART_CORTEX_A57: u32 = 3335;
pub const CPU_PART_CORTEX_A72: u32 = 3336;
pub const CPU_PART_CORTEX_A73: u32 = 3337;
pub const CPU_PART_CORTEX_A75: u32 = 3338;
pub const CPU_PART_CORTEX_A76: u32 = 3339;
pub const CPU_PART_NEOVERSE_N1: u32 = 3340;
pub const CPU_PART_CORTEX_A77: u32 = 3341;
pub const CPU_PART_CORTEX_A76AE: u32 = 3342;
pub const CPU_PART_THUNDERX: u32 = 161;
pub const CPU_PART_THUNDERX_81XX: u32 = 162;
pub const CPU_PART_THUNDERX_83XX: u32 = 163;
pub const CPU_PART_THUNDERX2: u32 = 175;
pub const CPU_REV_THUNDERX_1_0: u32 = 0;
pub const CPU_REV_THUNDERX_1_1: u32 = 1;
pub const CPU_REV_THUNDERX2_0: u32 = 0;
pub const CPU_PART_EMAG8180: u32 = 0;
pub const CPU_IMPL_MASK: u32 = 4278190080;
pub const CPU_PART_MASK: u32 = 65520;
pub const CPU_VAR_MASK: u32 = 15728640;
pub const CPU_REV_MASK: u32 = 15;
pub const CPU_MATCH_ERRATA_CAVIUM_THUNDERX_1_1: u32 = 0;
pub const ALT_STACK_SIZE: u32 = 128;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\0";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\0";
pub const DPCPU_MODMIN: u32 = 2048;
pub const UMA_PCPU_ALLOC_SIZE: u32 = 4096;
pub const HASH_NOWAIT: u32 = 1;
pub const HASH_WAITOK: u32 = 2;
pub const HD_COLUMN_MASK: u32 = 255;
pub const HD_DELIM_MASK: u32 = 65280;
pub const HD_OMIT_COUNT: u32 = 65536;
pub const HD_OMIT_HEX: u32 = 131072;
pub const HD_OMIT_CHARS: u32 = 262144;
pub const GETENV_UNSIGNED: u32 = 0;
pub const GETENV_SIGNED: u32 = 1;
pub const LIBKERN_LEN_BCD2BIN: u32 = 154;
pub const LIBKERN_LEN_BIN2BCD: u32 = 100;
pub const LIBKERN_LEN_HEX2ASCII: u32 = 36;
pub const ARC4_ENTR_NONE: u32 = 0;
pub const ARC4_ENTR_HAVE: u32 = 1;
pub const ARC4_ENTR_SEED: u32 = 2;
pub const FNM_NOMATCH: u32 = 1;
pub const FNM_NOESCAPE: u32 = 1;
pub const FNM_PATHNAME: u32 = 2;
pub const FNM_PERIOD: u32 = 4;
pub const FNM_LEADING_DIR: u32 = 8;
pub const FNM_CASEFOLD: u32 = 16;
pub const FNM_IGNORECASE: u32 = 16;
pub const FNM_FILE_NAME: u32 = 2;
pub const M_NOWAIT: u32 = 1;
pub const M_WAITOK: u32 = 2;
pub const M_ZERO: u32 = 256;
pub const M_NOVM: u32 = 512;
pub const M_USE_RESERVE: u32 = 1024;
pub const M_NODUMP: u32 = 2048;
pub const M_FIRSTFIT: u32 = 4096;
pub const M_BESTFIT: u32 = 8192;
pub const M_EXEC: u32 = 16384;
pub const M_NEXTFIT: u32 = 32768;
pub const M_MAGIC: u32 = 877983977;
pub const DTMALLOC_PROBE_MALLOC: u32 = 0;
pub const DTMALLOC_PROBE_FREE: u32 = 1;
pub const DTMALLOC_PROBE_MAX: u32 = 2;
pub const MALLOC_TYPE_STREAM_VERSION: u32 = 1;
pub const MALLOC_MAX_NAME: u32 = 32;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::std::os::raw::c_uint;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::std::os::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::std::os::raw::c_int;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __cpuwhich_t = ::std::os::raw::c_int;
pub type __cpulevel_t = ::std::os::raw::c_int;
pub type __cpusetid_t = ::std::os::raw::c_int;
pub type __daddr_t = __int64_t;
pub type __ct_rune_t = ::std::os::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __max_align_t {
    pub __max_align1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: u128,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<__max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(__max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(__max_align_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__max_align_t>())).__max_align1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__max_align_t),
            "::",
            stringify!(__max_align1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__max_align_t>())).__max_align2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__max_align_t),
            "::",
            stringify!(__max_align2)
        )
    );
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __rman_res_t = __uintmax_t;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::std::os::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::std::os::raw::c_void;
pub type pthread_startroutine_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once {
    pub state: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(
        ::std::mem::size_of::<pthread_once>(),
        16usize,
        concat!("Size of: ", stringify!(pthread_once))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_once>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_once))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_once>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_once>())).mutex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once),
            "::",
            stringify!(mutex)
        )
    );
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type c_caddr_t = *const ::std::os::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __daddr_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type size_t = __size_t;
pub type ssize_t = __ssize_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type kpaddr_t = __uint64_t;
pub type kvaddr_t = __uint64_t;
pub type ksize_t = __uint64_t;
pub type kssize_t = __int64_t;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __uint64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(
        ::std::mem::size_of::<__sigset>(),
        16usize,
        concat!("Size of: ", stringify!(__sigset))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset>(),
        4usize,
        concat!("Alignment of ", stringify!(__sigset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset),
            "::",
            stringify!(__bits)
        )
    );
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub const modeventtype_MOD_LOAD: modeventtype = 0;
pub const modeventtype_MOD_UNLOAD: modeventtype = 1;
pub const modeventtype_MOD_SHUTDOWN: modeventtype = 2;
pub const modeventtype_MOD_QUIESCE: modeventtype = 3;
pub type modeventtype = u32;
pub use self::modeventtype as modeventtype_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
pub type module_t = *mut module;
pub type modeventhand_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: module_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct moduledata {
    pub name: *const ::std::os::raw::c_char,
    pub evhand: modeventhand_t,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_moduledata() {
    assert_eq!(
        ::std::mem::size_of::<moduledata>(),
        24usize,
        concat!("Size of: ", stringify!(moduledata))
    );
    assert_eq!(
        ::std::mem::align_of::<moduledata>(),
        8usize,
        concat!("Alignment of ", stringify!(moduledata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<moduledata>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(moduledata),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<moduledata>())).evhand as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(moduledata),
            "::",
            stringify!(evhand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<moduledata>())).priv_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(moduledata),
            "::",
            stringify!(priv_)
        )
    );
}
pub type moduledata_t = moduledata;
#[repr(C)]
#[derive(Copy, Clone)]
pub union modspecific {
    pub intval: ::std::os::raw::c_int,
    pub uintval: u_int,
    pub longval: ::std::os::raw::c_long,
    pub ulongval: u_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_modspecific() {
    assert_eq!(
        ::std::mem::size_of::<modspecific>(),
        8usize,
        concat!("Size of: ", stringify!(modspecific))
    );
    assert_eq!(
        ::std::mem::align_of::<modspecific>(),
        8usize,
        concat!("Alignment of ", stringify!(modspecific))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<modspecific>())).intval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(modspecific),
            "::",
            stringify!(intval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<modspecific>())).uintval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(modspecific),
            "::",
            stringify!(uintval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<modspecific>())).longval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(modspecific),
            "::",
            stringify!(longval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<modspecific>())).ulongval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(modspecific),
            "::",
            stringify!(ulongval)
        )
    );
}
pub type modspecific_t = modspecific;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_depend {
    pub md_ver_minimum: ::std::os::raw::c_int,
    pub md_ver_preferred: ::std::os::raw::c_int,
    pub md_ver_maximum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mod_depend() {
    assert_eq!(
        ::std::mem::size_of::<mod_depend>(),
        12usize,
        concat!("Size of: ", stringify!(mod_depend))
    );
    assert_eq!(
        ::std::mem::align_of::<mod_depend>(),
        4usize,
        concat!("Alignment of ", stringify!(mod_depend))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_depend>())).md_ver_minimum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_depend),
            "::",
            stringify!(md_ver_minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_depend>())).md_ver_preferred as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_depend),
            "::",
            stringify!(md_ver_preferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_depend>())).md_ver_maximum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_depend),
            "::",
            stringify!(md_ver_maximum)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_version {
    pub mv_version: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mod_version() {
    assert_eq!(
        ::std::mem::size_of::<mod_version>(),
        4usize,
        concat!("Size of: ", stringify!(mod_version))
    );
    assert_eq!(
        ::std::mem::align_of::<mod_version>(),
        4usize,
        concat!("Alignment of ", stringify!(mod_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_version>())).mv_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_version),
            "::",
            stringify!(mv_version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_metadata {
    pub md_version: ::std::os::raw::c_int,
    pub md_type: ::std::os::raw::c_int,
    pub md_data: *const ::std::os::raw::c_void,
    pub md_cval: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mod_metadata() {
    assert_eq!(
        ::std::mem::size_of::<mod_metadata>(),
        24usize,
        concat!("Size of: ", stringify!(mod_metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<mod_metadata>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_metadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_metadata>())).md_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_metadata),
            "::",
            stringify!(md_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_metadata>())).md_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_metadata),
            "::",
            stringify!(md_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_metadata>())).md_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_metadata),
            "::",
            stringify!(md_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_metadata>())).md_cval as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_metadata),
            "::",
            stringify!(md_cval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_pnp_match_info {
    pub descr: *const ::std::os::raw::c_char,
    pub bus: *const ::std::os::raw::c_char,
    pub table: *const ::std::os::raw::c_void,
    pub entry_len: ::std::os::raw::c_int,
    pub num_entry: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mod_pnp_match_info() {
    assert_eq!(
        ::std::mem::size_of::<mod_pnp_match_info>(),
        32usize,
        concat!("Size of: ", stringify!(mod_pnp_match_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mod_pnp_match_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_pnp_match_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_pnp_match_info>())).descr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(descr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_pnp_match_info>())).bus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_pnp_match_info>())).table as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_pnp_match_info>())).entry_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(entry_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mod_pnp_match_info>())).num_entry as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(num_entry)
        )
    );
}
#[doc = " descr is a string that describes each entry in the table. The general"]
#[doc = " form is the grammar (TYPE:pnp_name[/pnp_name];)*"]
#[doc = " where TYPE is one of the following:"]
#[doc = "\tU8\tuint8_t element"]
#[doc = "\tV8\tlike U8 and 0xff means match any"]
#[doc = "\tG16\tuint16_t element, any value >= matches"]
#[doc = "\tL16\tuint16_t element, any value <= matches"]
#[doc = "\tM16\tuint16_t element, mask of which of the following fields to use."]
#[doc = "\tU16\tuint16_t element"]
#[doc = "\tV16\tlike U16 and 0xffff means match any"]
#[doc = "\tU32\tuint32_t element"]
#[doc = "\tV32\tlike U32 and 0xffffffff means match any"]
#[doc = "\tW32\tTwo 16-bit values with first pnp_name in LSW and second in MSW."]
#[doc = "\tZ\tpointer to a string to match exactly"]
#[doc = "\tD\tpointer to a string to human readable description for device"]
#[doc = "\tP\tA pointer that should be ignored"]
#[doc = "\tE\tEISA PNP Identifier (in binary, but bus publishes string)"]
#[doc = "\tT\tKey for whole table. pnp_name=value. must be last, if present."]
#[doc = ""]
#[doc = " The pnp_name \"#\" is reserved for other fields that should be ignored."]
#[doc = " Otherwise pnp_name must match the name from the parent device's pnpinfo"]
#[doc = " output. The second pnp_name is used for the W32 type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(
        ::std::mem::size_of::<sx>(),
        32usize,
        concat!("Size of: ", stringify!(sx))
    );
    assert_eq!(
        ::std::mem::align_of::<sx>(),
        8usize,
        concat!("Alignment of ", stringify!(sx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sx>())).lock_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sx),
            "::",
            stringify!(lock_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sx>())).sx_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sx),
            "::",
            stringify!(sx_lock)
        )
    );
}
extern "C" {
    pub static mut modules_sx: sx;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn module_register_init(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn module_register(
        arg1: *const moduledata,
        arg2: *mut linker_file,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn module_lookupbyname(arg1: *const ::std::os::raw::c_char) -> module_t;
}
extern "C" {
    pub fn module_lookupbyid(arg1: ::std::os::raw::c_int) -> module_t;
}
extern "C" {
    pub fn module_quiesce(arg1: module_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn module_reference(arg1: module_t);
}
extern "C" {
    pub fn module_release(arg1: module_t);
}
extern "C" {
    pub fn module_unload(arg1: module_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn module_getid(arg1: module_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn module_getfnext(arg1: module_t) -> module_t;
}
extern "C" {
    pub fn module_getname(arg1: module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn module_setspecific(arg1: module_t, arg2: *mut modspecific_t);
}
extern "C" {
    pub fn module_file(arg1: module_t) -> *mut linker_file;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_stat {
    pub version: ::std::os::raw::c_int,
    pub name: [::std::os::raw::c_char; 32usize],
    pub refs: ::std::os::raw::c_int,
    pub id: ::std::os::raw::c_int,
    pub data: modspecific_t,
}
#[test]
fn bindgen_test_layout_module_stat() {
    assert_eq!(
        ::std::mem::size_of::<module_stat>(),
        56usize,
        concat!("Size of: ", stringify!(module_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<module_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(module_stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<module_stat>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<module_stat>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<module_stat>())).refs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<module_stat>())).id as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<module_stat>())).data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(
        ::std::mem::size_of::<bintime>(),
        16usize,
        concat!("Size of: ", stringify!(bintime))
    );
    assert_eq!(
        ::std::mem::align_of::<bintime>(),
        8usize,
        concat!("Alignment of ", stringify!(bintime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bintime>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bintime),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bintime>())).frac as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bintime),
            "::",
            stringify!(frac)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub spare: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(
        ::std::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).tick as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).spare as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(spare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).stathz as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(stathz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).profhz as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(profhz)
        )
    );
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    pub static mut time_second: time_t;
}
extern "C" {
    pub static mut time_uptime: time_t;
}
extern "C" {
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    pub static mut tick_bt: bintime;
}
extern "C" {
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    pub static mut tc_precexp: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut tc_timepercentage: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    pub static mut rtc_generation: ::std::os::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(
        ::std::mem::size_of::<priority>(),
        4usize,
        concat!("Size of: ", stringify!(priority))
    );
    assert_eq!(
        ::std::mem::align_of::<priority>(),
        1usize,
        concat!("Alignment of ", stringify!(priority))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<priority>())).pri_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(priority),
            "::",
            stringify!(pri_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<priority>())).pri_level as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(priority),
            "::",
            stringify!(pri_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<priority>())).pri_native as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(priority),
            "::",
            stringify!(pri_native)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<priority>())).pri_user as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(priority),
            "::",
            stringify!(pri_user)
        )
    );
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub static mut lse_supported: bool_;
}
extern "C" {
    pub fn pan_enable();
}
extern "C" {
    pub static mut icache_aliasing: bool_;
}
extern "C" {
    pub static mut icache_vmid: bool_;
}
extern "C" {
    pub static mut dcache_line_size: i64;
}
extern "C" {
    pub static mut icache_line_size: i64;
}
extern "C" {
    pub static mut idcache_line_size: i64;
}
extern "C" {
    pub static mut dczva_line_size: i64;
}
extern "C" {
    pub fn arm64_nullop();
}
extern "C" {
    pub fn arm64_tlb_flushID();
}
extern "C" {
    pub fn arm64_icache_sync_range(arg1: vm_offset_t, arg2: vm_size_t);
}
extern "C" {
    pub fn arm64_icache_sync_range_checked(
        arg1: vm_offset_t,
        arg2: vm_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arm64_idcache_wbinv_range(arg1: vm_offset_t, arg2: vm_size_t);
}
extern "C" {
    pub fn arm64_dcache_wbinv_range(arg1: vm_offset_t, arg2: vm_size_t);
}
extern "C" {
    pub fn arm64_dcache_inv_range(arg1: vm_offset_t, arg2: vm_size_t);
}
extern "C" {
    pub fn arm64_dcache_wb_range(arg1: vm_offset_t, arg2: vm_size_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout_list {
    pub lh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_list() {
    assert_eq!(
        ::std::mem::size_of::<callout_list>(),
        8usize,
        concat!("Size of: ", stringify!(callout_list))
    );
    assert_eq!(
        ::std::mem::align_of::<callout_list>(),
        8usize,
        concat!("Alignment of ", stringify!(callout_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout_list>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout_list),
            "::",
            stringify!(lh_first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout_slist {
    pub slh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_slist() {
    assert_eq!(
        ::std::mem::size_of::<callout_slist>(),
        8usize,
        concat!("Size of: ", stringify!(callout_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<callout_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(callout_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout_slist>())).slh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout_slist),
            "::",
            stringify!(slh_first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout_tailq {
    pub tqh_first: *mut callout,
    pub tqh_last: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout_tailq() {
    assert_eq!(
        ::std::mem::size_of::<callout_tailq>(),
        16usize,
        concat!("Size of: ", stringify!(callout_tailq))
    );
    assert_eq!(
        ::std::mem::align_of::<callout_tailq>(),
        8usize,
        concat!("Alignment of ", stringify!(callout_tailq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout_tailq>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout_tailq),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout_tailq>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callout_tailq),
            "::",
            stringify!(tqh_last)
        )
    );
}
pub type callout_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct callout {
    pub c_links: callout__bindgen_ty_1,
    pub c_time: sbintime_t,
    pub c_precision: sbintime_t,
    pub c_arg: *mut ::std::os::raw::c_void,
    pub c_func: callout_func_t,
    pub c_lock: *mut lock_object,
    pub c_flags: ::std::os::raw::c_short,
    pub c_iflags: ::std::os::raw::c_short,
    pub c_cpu: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union callout__bindgen_ty_1 {
    pub le: callout__bindgen_ty_1__bindgen_ty_1,
    pub sle: callout__bindgen_ty_1__bindgen_ty_2,
    pub tqe: callout__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout,
    pub le_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(callout__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<callout__bindgen_ty_1__bindgen_ty_1>())).le_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<callout__bindgen_ty_1__bindgen_ty_1>())).le_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(callout__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<callout__bindgen_ty_1__bindgen_ty_2>())).sle_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sle_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout,
    pub tqe_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(callout__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<callout__bindgen_ty_1__bindgen_ty_3>())).tqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<callout__bindgen_ty_1__bindgen_ty_3>())).tqe_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<callout__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(callout__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<callout__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(callout__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout__bindgen_ty_1>())).le as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1),
            "::",
            stringify!(le)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout__bindgen_ty_1>())).sle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1),
            "::",
            stringify!(sle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout__bindgen_ty_1>())).tqe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1),
            "::",
            stringify!(tqe)
        )
    );
}
#[test]
fn bindgen_test_layout_callout() {
    assert_eq!(
        ::std::mem::size_of::<callout>(),
        64usize,
        concat!("Size of: ", stringify!(callout))
    );
    assert_eq!(
        ::std::mem::align_of::<callout>(),
        8usize,
        concat!("Alignment of ", stringify!(callout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout>())).c_links as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout>())).c_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout>())).c_precision as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout>())).c_arg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout>())).c_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout>())).c_lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout>())).c_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout>())).c_iflags as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_iflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callout>())).c_cpu as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_cpu)
        )
    );
}
extern "C" {
    pub fn callout_init(arg1: *mut callout, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _callout_init_lock(
        arg1: *mut callout,
        arg2: *mut lock_object,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn callout_reset_sbt_on(
        arg1: *mut callout,
        arg2: sbintime_t,
        arg3: sbintime_t,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg5: *mut ::std::os::raw::c_void,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn callout_schedule(
        arg1: *mut callout,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn callout_schedule_on(
        arg1: *mut callout,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _callout_stop_safe(
        arg1: *mut callout,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn callout_process(now: sbintime_t);
}
extern "C" {
    pub fn callout_when(
        sbt: sbintime_t,
        precision: sbintime_t,
        flags: ::std::os::raw::c_int,
        sbt_res: *mut sbintime_t,
        prec_res: *mut sbintime_t,
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
extern "C" {
    pub static mut cold: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut suspend_blocked: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rebooting: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panicstr: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut panicked: bool_;
}
extern "C" {
    pub static mut version: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut compiler_version: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut copyright: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut kstack_pages: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut pagesizes: [u_long; 0usize];
}
extern "C" {
    pub static mut physmem: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut realmem: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut rootdevnames: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut boothowto: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut bootverbose: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut maxusers: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut ngroups_max: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut vm_guest: ::std::os::raw::c_int;
}
pub const VM_GUEST_VM_GUEST_NO: VM_GUEST = 0;
pub const VM_GUEST_VM_GUEST_VM: VM_GUEST = 1;
pub const VM_GUEST_VM_GUEST_XEN: VM_GUEST = 2;
pub const VM_GUEST_VM_GUEST_HV: VM_GUEST = 3;
pub const VM_GUEST_VM_GUEST_VMWARE: VM_GUEST = 4;
pub const VM_GUEST_VM_GUEST_KVM: VM_GUEST = 5;
pub const VM_GUEST_VM_GUEST_BHYVE: VM_GUEST = 6;
pub const VM_GUEST_VM_GUEST_VBOX: VM_GUEST = 7;
pub const VM_GUEST_VM_GUEST_PARALLELS: VM_GUEST = 8;
pub const VM_GUEST_VM_LAST: VM_GUEST = 9;
pub type VM_GUEST = u32;
extern "C" {
    pub fn panic(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vpanic(arg1: *const ::std::os::raw::c_char, arg2: __va_list);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitset {
    pub __bits: [::std::os::raw::c_long; 1usize],
}
#[test]
fn bindgen_test_layout_bitset() {
    assert_eq!(
        ::std::mem::size_of::<bitset>(),
        8usize,
        concat!("Size of: ", stringify!(bitset))
    );
    assert_eq!(
        ::std::mem::align_of::<bitset>(),
        8usize,
        concat!("Alignment of ", stringify!(bitset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bitset>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bitset),
            "::",
            stringify!(__bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cpuset {
    pub __bits: [::std::os::raw::c_long; 1usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(
        ::std::mem::size_of::<_cpuset>(),
        8usize,
        concat!("Size of: ", stringify!(_cpuset))
    );
    assert_eq!(
        ::std::mem::align_of::<_cpuset>(),
        8usize,
        concat!("Alignment of ", stringify!(_cpuset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_cpuset>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cpuset),
            "::",
            stringify!(__bits)
        )
    );
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_object {
    pub lo_name: *const ::std::os::raw::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut witness,
}
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(
        ::std::mem::size_of::<lock_object>(),
        24usize,
        concat!("Size of: ", stringify!(lock_object))
    );
    assert_eq!(
        ::std::mem::align_of::<lock_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lock_object))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lock_object>())).lo_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_object),
            "::",
            stringify!(lo_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lock_object>())).lo_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_object),
            "::",
            stringify!(lo_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lock_object>())).lo_data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_object),
            "::",
            stringify!(lo_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lock_object>())).lo_witness as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_object),
            "::",
            stringify!(lo_witness)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(
        ::std::mem::size_of::<mtx>(),
        32usize,
        concat!("Size of: ", stringify!(mtx))
    );
    assert_eq!(
        ::std::mem::align_of::<mtx>(),
        8usize,
        concat!("Alignment of ", stringify!(mtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mtx>())).lock_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx),
            "::",
            stringify!(lock_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mtx>())).mtx_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx),
            "::",
            stringify!(mtx_lock)
        )
    );
}
#[repr(C)]
#[repr(align(128))]
#[derive(Copy, Clone)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx_padalign() {
    assert_eq!(
        ::std::mem::size_of::<mtx_padalign>(),
        128usize,
        concat!("Size of: ", stringify!(mtx_padalign))
    );
    assert_eq!(
        ::std::mem::align_of::<mtx_padalign>(),
        128usize,
        concat!("Alignment of ", stringify!(mtx_padalign))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mtx_padalign>())).lock_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx_padalign),
            "::",
            stringify!(lock_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mtx_padalign>())).mtx_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx_padalign),
            "::",
            stringify!(mtx_lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(
        ::std::mem::size_of::<rmpriolist>(),
        8usize,
        concat!("Size of: ", stringify!(rmpriolist))
    );
    assert_eq!(
        ::std::mem::align_of::<rmpriolist>(),
        8usize,
        concat!("Alignment of ", stringify!(rmpriolist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmpriolist>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmpriolist),
            "::",
            stringify!(lh_first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(
        ::std::mem::size_of::<rm_queue>(),
        16usize,
        concat!("Size of: ", stringify!(rm_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<rm_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(rm_queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rm_queue>())).rmq_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_queue),
            "::",
            stringify!(rmq_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rm_queue>())).rmq_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_queue),
            "::",
            stringify!(rmq_prev)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rmlock__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rmlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rmlock__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rmlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmlock__bindgen_ty_1>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rmlock__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(rmlock__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rmlock__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rmlock__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rmlock__bindgen_ty_2>()))._rm_wlock_object as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock__bindgen_ty_2),
            "::",
            stringify!(_rm_wlock_object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rmlock__bindgen_ty_2>()))._rm_lock_mtx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock__bindgen_ty_2),
            "::",
            stringify!(_rm_lock_mtx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rmlock__bindgen_ty_2>()))._rm_lock_sx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock__bindgen_ty_2),
            "::",
            stringify!(_rm_lock_sx)
        )
    );
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(
        ::std::mem::size_of::<rmlock>(),
        72usize,
        concat!("Size of: ", stringify!(rmlock))
    );
    assert_eq!(
        ::std::mem::align_of::<rmlock>(),
        8usize,
        concat!("Alignment of ", stringify!(rmlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmlock>())).lock_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock),
            "::",
            stringify!(lock_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmlock>())).rm_writecpus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock),
            "::",
            stringify!(rm_writecpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmlock>())).rm_activeReaders as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock),
            "::",
            stringify!(rm_activeReaders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmlock>()))._rm_lock as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock),
            "::",
            stringify!(_rm_lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::std::os::raw::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rm_priotracker__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rm_priotracker__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rm_priotracker__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rm_priotracker__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rm_priotracker__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rm_priotracker__bindgen_ty_1>())).le_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rm_priotracker__bindgen_ty_1>())).le_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rm_priotracker() {
    assert_eq!(
        ::std::mem::size_of::<rm_priotracker>(),
        56usize,
        concat!("Size of: ", stringify!(rm_priotracker))
    );
    assert_eq!(
        ::std::mem::align_of::<rm_priotracker>(),
        8usize,
        concat!("Alignment of ", stringify!(rm_priotracker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rm_priotracker>())).rmp_cpuQueue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_cpuQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rm_priotracker>())).rmp_rmlock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_rmlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rm_priotracker>())).rmp_thread as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rm_priotracker>())).rmp_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rm_priotracker>())).rmp_qentry as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_qentry)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmslock {
    pub mtx: mtx,
    pub writers: ::std::os::raw::c_int,
    pub readers: ::std::os::raw::c_int,
    pub readers_pcpu: *mut ::std::os::raw::c_int,
    pub readers_influx: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rmslock() {
    assert_eq!(
        ::std::mem::size_of::<rmslock>(),
        56usize,
        concat!("Size of: ", stringify!(rmslock))
    );
    assert_eq!(
        ::std::mem::align_of::<rmslock>(),
        8usize,
        concat!("Alignment of ", stringify!(rmslock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmslock>())).mtx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmslock),
            "::",
            stringify!(mtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmslock>())).writers as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rmslock),
            "::",
            stringify!(writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmslock>())).readers as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rmslock),
            "::",
            stringify!(readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmslock>())).readers_pcpu as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rmslock),
            "::",
            stringify!(readers_pcpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rmslock>())).readers_influx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rmslock),
            "::",
            stringify!(readers_influx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(
        ::std::mem::size_of::<__wrusage>(),
        288usize,
        concat!("Size of: ", stringify!(__wrusage))
    );
    assert_eq!(
        ::std::mem::align_of::<__wrusage>(),
        8usize,
        concat!("Alignment of ", stringify!(__wrusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__wrusage>())).wru_self as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wrusage),
            "::",
            stringify!(wru_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__wrusage>())).wru_children as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__wrusage),
            "::",
            stringify!(wru_children)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(
        ::std::mem::size_of::<orlimit>(),
        8usize,
        concat!("Size of: ", stringify!(orlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<orlimit>(),
        4usize,
        concat!("Alignment of ", stringify!(orlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<orlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(orlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<orlimit>())).rlim_max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(orlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(
        ::std::mem::size_of::<loadavg>(),
        24usize,
        concat!("Size of: ", stringify!(loadavg))
    );
    assert_eq!(
        ::std::mem::align_of::<loadavg>(),
        8usize,
        concat!("Alignment of ", stringify!(loadavg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<loadavg>())).ldavg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loadavg),
            "::",
            stringify!(ldavg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<loadavg>())).fscale as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(loadavg),
            "::",
            stringify!(fscale)
        )
    );
}
extern "C" {
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut ::std::os::raw::c_long);
}
pub type sig_atomic_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub _dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        4usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        4usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>()))._dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(_dummy)
        )
    );
}
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    pub sigval_int: ::std::os::raw::c_int,
    pub sigval_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sigval_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sigval_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sigval_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sigval_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval32 {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: u32,
    pub sigval_int: ::std::os::raw::c_int,
    pub sigval_ptr: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sigval32() {
    assert_eq!(
        ::std::mem::size_of::<sigval32>(),
        4usize,
        concat!("Size of: ", stringify!(sigval32))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval32>(),
        4usize,
        concat!("Alignment of ", stringify!(sigval32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval32>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval32),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval32>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval32),
            "::",
            stringify!(sival_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval32>())).sigval_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval32),
            "::",
            stringify!(sigval_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval32>())).sigval_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval32),
            "::",
            stringify!(sigval_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _threadid: __lwpid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    pub _kevent_flags: ::std::os::raw::c_ushort,
    pub __spare__: [::std::os::raw::c_long; 8usize],
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub _attribute: *mut *mut pthread_attr,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._threadid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_threadid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._kevent_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_kevent_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>())).__spare__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(__spare__)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        80usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub _reason: __siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __siginfo__bindgen_ty_1 {
    pub _fault: __siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _timer: __siginfo__bindgen_ty_1__bindgen_ty_2,
    pub _mesgq: __siginfo__bindgen_ty_1__bindgen_ty_3,
    pub _poll: __siginfo__bindgen_ty_1__bindgen_ty_4,
    pub __spare__: __siginfo__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__siginfo__bindgen_ty_1__bindgen_ty_1>()))._trapno as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_trapno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::std::os::raw::c_int,
    pub _overrun: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__siginfo__bindgen_ty_1__bindgen_ty_2>()))._timerid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_timerid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__siginfo__bindgen_ty_1__bindgen_ty_2>()))._overrun as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__siginfo__bindgen_ty_1__bindgen_ty_3>()))._mqd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_mqd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _band: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__siginfo__bindgen_ty_1__bindgen_ty_4>()))._band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_band)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub __spare1__: ::std::os::raw::c_long,
    pub __spare2__: [::std::os::raw::c_int; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_5>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__siginfo__bindgen_ty_1__bindgen_ty_5>())).__spare1__ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(__spare1__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__siginfo__bindgen_ty_1__bindgen_ty_5>())).__spare2__ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(__spare2__)
        )
    );
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(__siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo__bindgen_ty_1>()))._fault as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1),
            "::",
            stringify!(_fault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo__bindgen_ty_1>()))._mesgq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1),
            "::",
            stringify!(_mesgq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo__bindgen_ty_1>()))._poll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1),
            "::",
            stringify!(_poll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__siginfo__bindgen_ty_1>())).__spare__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo__bindgen_ty_1),
            "::",
            stringify!(__spare__)
        )
    );
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        80usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>()))._reason as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(_reason)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo32 {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: u32,
    pub si_value: sigval32,
    pub _reason: siginfo32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo32__bindgen_ty_1 {
    pub _fault: siginfo32__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo32__bindgen_ty_1__bindgen_ty_2,
    pub _mesgq: siginfo32__bindgen_ty_1__bindgen_ty_3,
    pub _poll: siginfo32__bindgen_ty_1__bindgen_ty_4,
    pub __spare__: siginfo32__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo32__bindgen_ty_1__bindgen_ty_1>()))._trapno as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_trapno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::std::os::raw::c_int,
    pub _overrun: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo32__bindgen_ty_1__bindgen_ty_2>()))._timerid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_timerid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo32__bindgen_ty_1__bindgen_ty_2>()))._overrun as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo32__bindgen_ty_1__bindgen_ty_3>()))._mqd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_mqd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_4 {
    pub _band: i32,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo32__bindgen_ty_1__bindgen_ty_4>()))._band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_band)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_5 {
    pub __spare1__: i32,
    pub __spare2__: [::std::os::raw::c_int; 7usize],
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo32__bindgen_ty_1__bindgen_ty_5>())).__spare1__ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(__spare1__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo32__bindgen_ty_1__bindgen_ty_5>())).__spare2__ as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(__spare2__)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo32__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(siginfo32__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo32__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(siginfo32__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32__bindgen_ty_1>()))._fault as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1),
            "::",
            stringify!(_fault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32__bindgen_ty_1>()))._mesgq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1),
            "::",
            stringify!(_mesgq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32__bindgen_ty_1>()))._poll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1),
            "::",
            stringify!(_poll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo32__bindgen_ty_1>())).__spare__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32__bindgen_ty_1),
            "::",
            stringify!(__spare__)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo32() {
    assert_eq!(
        ::std::mem::size_of::<siginfo32>(),
        64usize,
        concat!("Size of: ", stringify!(siginfo32))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo32>(),
        4usize,
        concat!("Alignment of ", stringify!(siginfo32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32>())).si_value as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo32>()))._reason as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo32),
            "::",
            stringify!(_reason)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: sigaction__bindgen_ty_1,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).__sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).__sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        32usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
}
pub type sig_t = __sighandler_t;
pub type __siginfohandler_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut __siginfo,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: __sighandler_t,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(arg1: ::std::os::raw::c_int, arg2: __sighandler_t) -> __sighandler_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpregs {
    pub gp_x: [__register_t; 30usize],
    pub gp_lr: __register_t,
    pub gp_sp: __register_t,
    pub gp_elr: __register_t,
    pub gp_spsr: __uint32_t,
    pub gp_pad: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_gpregs() {
    assert_eq!(
        ::std::mem::size_of::<gpregs>(),
        272usize,
        concat!("Size of: ", stringify!(gpregs))
    );
    assert_eq!(
        ::std::mem::align_of::<gpregs>(),
        8usize,
        concat!("Alignment of ", stringify!(gpregs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpregs>())).gp_x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpregs),
            "::",
            stringify!(gp_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpregs>())).gp_lr as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(gpregs),
            "::",
            stringify!(gp_lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpregs>())).gp_sp as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(gpregs),
            "::",
            stringify!(gp_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpregs>())).gp_elr as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(gpregs),
            "::",
            stringify!(gp_elr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpregs>())).gp_spsr as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(gpregs),
            "::",
            stringify!(gp_spsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpregs>())).gp_pad as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(gpregs),
            "::",
            stringify!(gp_pad)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct fpregs {
    pub fp_q: [__uint128_t; 32usize],
    pub fp_sr: __uint32_t,
    pub fp_cr: __uint32_t,
    pub fp_flags: ::std::os::raw::c_int,
    pub fp_pad: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fpregs() {
    assert_eq!(
        ::std::mem::size_of::<fpregs>(),
        528usize,
        concat!("Size of: ", stringify!(fpregs))
    );
    assert_eq!(
        ::std::mem::align_of::<fpregs>(),
        16usize,
        concat!("Alignment of ", stringify!(fpregs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs>())).fp_q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs),
            "::",
            stringify!(fp_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs>())).fp_sr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs),
            "::",
            stringify!(fp_sr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs>())).fp_cr as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs),
            "::",
            stringify!(fp_cr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs>())).fp_flags as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs),
            "::",
            stringify!(fp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs>())).fp_pad as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs),
            "::",
            stringify!(fp_pad)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __mcontext {
    pub mc_gpregs: gpregs,
    pub mc_fpregs: fpregs,
    pub mc_flags: ::std::os::raw::c_int,
    pub mc_pad: ::std::os::raw::c_int,
    pub mc_spare: [__uint64_t; 8usize],
}
#[test]
fn bindgen_test_layout___mcontext() {
    assert_eq!(
        ::std::mem::size_of::<__mcontext>(),
        880usize,
        concat!("Size of: ", stringify!(__mcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__mcontext>(),
        16usize,
        concat!("Alignment of ", stringify!(__mcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mcontext>())).mc_gpregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mcontext),
            "::",
            stringify!(mc_gpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mcontext>())).mc_fpregs as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(__mcontext),
            "::",
            stringify!(mc_fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mcontext>())).mc_flags as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(__mcontext),
            "::",
            stringify!(mc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mcontext>())).mc_pad as *const _ as usize },
        804usize,
        concat!(
            "Offset of field: ",
            stringify!(__mcontext),
            "::",
            stringify!(mc_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mcontext>())).mc_spare as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(__mcontext),
            "::",
            stringify!(mc_spare)
        )
    );
}
pub type mcontext_t = __mcontext;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __ucontext {
    pub uc_sigmask: __sigset_t,
    pub uc_mcontext: mcontext_t,
    pub uc_link: *mut __ucontext,
    pub uc_stack: sigaltstack,
    pub uc_flags: ::std::os::raw::c_int,
    pub __spare__: [::std::os::raw::c_int; 4usize],
}
#[test]
fn bindgen_test_layout___ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__ucontext>(),
        960usize,
        concat!("Size of: ", stringify!(__ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__ucontext>(),
        16usize,
        concat!("Alignment of ", stringify!(__ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__ucontext>())).uc_sigmask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__ucontext>())).uc_mcontext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__ucontext>())).uc_link as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(__ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__ucontext>())).uc_stack as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(__ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__ucontext>())).uc_flags as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(__ucontext),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__ucontext>())).__spare__ as *const _ as usize },
        932usize,
        concat!(
            "Offset of field: ",
            stringify!(__ucontext),
            "::",
            stringify!(__spare__)
        )
    );
}
pub type ucontext_t = __ucontext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
extern "C" {
    pub fn get_mcontext(
        arg1: *mut thread,
        arg2: *mut mcontext_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_mcontext(arg1: *mut thread, arg2: *mut mcontext_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trapframe {
    pub tf_sp: u64,
    pub tf_lr: u64,
    pub tf_elr: u64,
    pub tf_spsr: u32,
    pub tf_esr: u32,
    pub tf_x: [u64; 30usize],
}
#[test]
fn bindgen_test_layout_trapframe() {
    assert_eq!(
        ::std::mem::size_of::<trapframe>(),
        272usize,
        concat!("Size of: ", stringify!(trapframe))
    );
    assert_eq!(
        ::std::mem::align_of::<trapframe>(),
        8usize,
        concat!("Alignment of ", stringify!(trapframe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trapframe>())).tf_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trapframe),
            "::",
            stringify!(tf_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trapframe>())).tf_lr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trapframe),
            "::",
            stringify!(tf_lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trapframe>())).tf_elr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(trapframe),
            "::",
            stringify!(tf_elr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trapframe>())).tf_spsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(trapframe),
            "::",
            stringify!(tf_spsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trapframe>())).tf_esr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(trapframe),
            "::",
            stringify!(tf_esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trapframe>())).tf_x as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(trapframe),
            "::",
            stringify!(tf_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm64_frame {
    pub f_frame: *mut arm64_frame,
    pub f_retaddr: u_long,
}
#[test]
fn bindgen_test_layout_arm64_frame() {
    assert_eq!(
        ::std::mem::size_of::<arm64_frame>(),
        16usize,
        concat!("Size of: ", stringify!(arm64_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<arm64_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(arm64_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arm64_frame>())).f_frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm64_frame),
            "::",
            stringify!(f_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arm64_frame>())).f_retaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm64_frame),
            "::",
            stringify!(f_retaddr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct sigframe {
    pub sf_si: siginfo_t,
    pub sf_uc: ucontext_t,
}
#[test]
fn bindgen_test_layout_sigframe() {
    assert_eq!(
        ::std::mem::size_of::<sigframe>(),
        1040usize,
        concat!("Size of: ", stringify!(sigframe))
    );
    assert_eq!(
        ::std::mem::align_of::<sigframe>(),
        16usize,
        concat!("Alignment of ", stringify!(sigframe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigframe>())).sf_si as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigframe),
            "::",
            stringify!(sf_si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigframe>())).sf_uc as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigframe),
            "::",
            stringify!(sf_uc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frame {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_frame() {
    assert_eq!(
        ::std::mem::size_of::<frame>(),
        4usize,
        concat!("Size of: ", stringify!(frame))
    );
    assert_eq!(
        ::std::mem::align_of::<frame>(),
        4usize,
        concat!("Alignment of ", stringify!(frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    pub static mut btext: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut etext: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __cpu_affinity: [u64; 0usize];
}
extern "C" {
    pub fn cpu_halt();
}
extern "C" {
    pub fn cpu_reset();
}
extern "C" {
    pub fn fork_trampoline();
}
extern "C" {
    pub fn identify_cache(arg1: u64);
}
extern "C" {
    pub fn identify_cpu();
}
extern "C" {
    pub fn install_cpu_errata();
}
extern "C" {
    pub fn swi_vm(v: *mut ::std::os::raw::c_void);
}
pub type pcpu_bp_harden = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type pcpu_ssbd = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debug_monitor_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
#[repr(align(128))]
#[derive(Copy, Clone)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_sched: *mut ::std::os::raw::c_void,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::std::os::raw::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::std::os::raw::c_long; 5usize],
    pub pc_device: *mut device,
    pub pc_netisr: *mut ::std::os::raw::c_void,
    pub pc_unused1: ::std::os::raw::c_int,
    pub pc_domain: ::std::os::raw::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub pc_zpcpu_offset: usize,
    pub pc_acpi_id: u_int,
    pub pc_midr: u_int,
    pub pc_clock: u64,
    pub pc_bp_harden: pcpu_bp_harden,
    pub pc_ssbd: pcpu_ssbd,
    pub pc_curpmap: *mut pmap,
    pub pc_bcast_tlbi_workaround: u_int,
    pub __pad: [::std::os::raw::c_char; 213usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pcpu__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pcpu__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pcpu__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pcpu__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu__bindgen_ty_1>())).stqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[test]
fn bindgen_test_layout_pcpu() {
    assert_eq!(
        ::std::mem::size_of::<pcpu>(),
        512usize,
        concat!("Size of: ", stringify!(pcpu))
    );
    assert_eq!(
        ::std::mem::align_of::<pcpu>(),
        128usize,
        concat!("Alignment of ", stringify!(pcpu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_curthread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_curthread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_idlethread as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_idlethread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_fpcurthread as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_fpcurthread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_deadthread as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_deadthread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_curpcb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_curpcb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_sched as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_switchtime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_switchtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_switchticks as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_switchticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_cpuid as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_cpuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_allcpu as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_allcpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_spinlocks as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_spinlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_cp_time as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_cp_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_device as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_netisr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_netisr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_unused1 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_domain as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_rm_queue as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_rm_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_dynamic as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_dynamic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_early_dummy_counter as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_early_dummy_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_zpcpu_offset as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_zpcpu_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_acpi_id as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_acpi_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_midr as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_midr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_clock as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_clock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_bp_harden as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_bp_harden)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_ssbd as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_ssbd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_curpmap as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_curpmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).pc_bcast_tlbi_workaround as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_bcast_tlbi_workaround)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu>())).__pad as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(
        ::std::mem::size_of::<cpuhead>(),
        16usize,
        concat!("Size of: ", stringify!(cpuhead))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuhead>(),
        8usize,
        concat!("Alignment of ", stringify!(cpuhead))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuhead>())).stqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuhead),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuhead>())).stqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuhead),
            "::",
            stringify!(stqh_last)
        )
    );
}
extern "C" {
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub static mut __pcpu: [pcpu; 0usize];
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::std::os::raw::c_int, size: size_t);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut ::std::os::raw::c_void, cpuid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::std::os::raw::c_int, size: size_t);
}
extern "C" {
    pub static mut osreldate: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut dynamic_kenv: bool_;
}
extern "C" {
    pub static mut kenv_lock: mtx;
}
extern "C" {
    pub static mut kern_envp: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut md_envp: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut static_env: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut static_hints: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut kenvp: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut zero_region: *const ::std::os::raw::c_void;
}
extern "C" {
    pub static mut unmapped_buf_allowed: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inpcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmp_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventtimer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn setjmp(arg1: *mut _jmp_buf) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dumpstatus(addr: vm_offset_t, count: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nullop() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eopnotsupp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ureadc(arg1: ::std::os::raw::c_int, arg2: *mut uio) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hashdestroy(arg1: *mut ::std::os::raw::c_void, arg2: *mut malloc_type, arg3: u_long);
}
extern "C" {
    pub fn hashinit(
        count: ::std::os::raw::c_int,
        type_: *mut malloc_type,
        hashmask: *mut u_long,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hashinit_flags(
        count: ::std::os::raw::c_int,
        type_: *mut malloc_type,
        hashmask: *mut u_long,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn phashinit(
        count: ::std::os::raw::c_int,
        type_: *mut malloc_type,
        nentries: *mut u_long,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn phashinit_flags(
        count: ::std::os::raw::c_int,
        type_: *mut malloc_type,
        nentries: *mut u_long,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn g_waitidle();
}
extern "C" {
    pub fn cpu_boot(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cpu_flush_dcache(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
}
extern "C" {
    pub fn cpu_rootconf();
}
extern "C" {
    pub fn critical_enter_KBI();
}
extern "C" {
    pub fn critical_exit_KBI();
}
extern "C" {
    pub fn critical_exit_preempt();
}
extern "C" {
    pub fn init_param1();
}
extern "C" {
    pub fn init_param2(physpages: ::std::os::raw::c_long);
}
extern "C" {
    pub fn init_static_kenv(arg1: *mut ::std::os::raw::c_char, arg2: size_t);
}
extern "C" {
    pub fn tablefull(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut lkpi_alloc_current: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut thread,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn linux_alloc_current_noop(
        arg1: *mut thread,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kvprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut ::std::os::raw::c_void),
        >,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_int,
        arg5: __va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn log(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn log_console(arg1: *mut uio);
}
extern "C" {
    pub fn vlog(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char, arg3: __va_list);
}
extern "C" {
    pub fn asprintf(
        ret: *mut *mut ::std::os::raw::c_char,
        mtp: *mut malloc_type,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        buf: *mut ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprintf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char, arg2: __va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        ret: *mut *mut ::std::os::raw::c_char,
        mtp: *mut malloc_type,
        format: *const ::std::os::raw::c_char,
        ap: __va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: __va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnrprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: __va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        buf: *mut ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        arg2: __va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> u_long;
}
extern "C" {
    pub fn strtoq(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> quad_t;
}
extern "C" {
    pub fn strtouq(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> u_quad_t;
}
extern "C" {
    pub fn tprintf(
        p: *mut proc_,
        pri: ::std::os::raw::c_int,
        arg1: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn vtprintf(
        arg1: *mut proc_,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: __va_list,
    );
}
extern "C" {
    pub fn hexdump(
        ptr: *const ::std::os::raw::c_void,
        length: ::std::os::raw::c_int,
        hdr: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn bcopy(from: *const ::std::os::raw::c_void, to: *mut ::std::os::raw::c_void, len: size_t);
}
extern "C" {
    pub fn bzero(buf: *mut ::std::os::raw::c_void, len: size_t);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
}
extern "C" {
    pub fn bcmp(
        b1: *const ::std::os::raw::c_void,
        b2: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memset(
        buf: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcpy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        b1: *const ::std::os::raw::c_void,
        b2: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memset_early(
        buf: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcpy_early(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove_early(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn copystr(
        kfaddr: *const ::std::os::raw::c_void,
        kdaddr: *mut ::std::os::raw::c_void,
        len: size_t,
        lencopied: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyinstr(
        udaddr: *const ::std::os::raw::c_void,
        kaddr: *mut ::std::os::raw::c_void,
        len: size_t,
        lencopied: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyin(
        udaddr: *const ::std::os::raw::c_void,
        kaddr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyin_nofault(
        udaddr: *const ::std::os::raw::c_void,
        kaddr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyout(
        kaddr: *const ::std::os::raw::c_void,
        udaddr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyout_nofault(
        kaddr: *const ::std::os::raw::c_void,
        udaddr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fubyte(base: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuword(base: *const ::std::os::raw::c_void) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fuword16(base: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuword32(base: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    pub fn fuword64(base: *const ::std::os::raw::c_void) -> i64;
}
extern "C" {
    pub fn fueword(
        base: *const ::std::os::raw::c_void,
        val: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fueword32(base: *const ::std::os::raw::c_void, val: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fueword64(base: *const ::std::os::raw::c_void, val: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn subyte(
        base: *mut ::std::os::raw::c_void,
        byte: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword(
        base: *mut ::std::os::raw::c_void,
        word: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword16(
        base: *mut ::std::os::raw::c_void,
        word: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword32(base: *mut ::std::os::raw::c_void, word: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword64(base: *mut ::std::os::raw::c_void, word: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
}
extern "C" {
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
}
extern "C" {
    pub fn casueword32(
        base: *mut u32,
        oldval: u32,
        oldvalp: *mut u32,
        newval: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn casueword(
        p: *mut u_long,
        oldval: u_long,
        oldvalp: *mut u_long,
        newval: u_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realitexpire(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn sysbeep(
        hertz: ::std::os::raw::c_int,
        period: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hardclock(cnt: ::std::os::raw::c_int, usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hardclock_sync(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn softclock(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn statclock(cnt: ::std::os::raw::c_int, usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn profclock(cnt: ::std::os::raw::c_int, usermode: ::std::os::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclockintr() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn startprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn stopprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn cpu_startprofclock();
}
extern "C" {
    pub fn cpu_stopprofclock();
}
extern "C" {
    pub fn suspendclock();
}
extern "C" {
    pub fn resumeclock();
}
extern "C" {
    pub fn cpu_idleclock() -> sbintime_t;
}
extern "C" {
    pub fn cpu_activeclock();
}
extern "C" {
    pub fn cpu_new_callout(cpu: ::std::os::raw::c_int, bt: sbintime_t, bt_opt: sbintime_t);
}
extern "C" {
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
}
extern "C" {
    pub static mut cpu_disable_c2_sleep: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut cpu_disable_c3_sleep: ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_getenv(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn freeenv(env: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn getenv_int(
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_uint(
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_long(
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_ulong(
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_string(
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_int64(
        name: *const ::std::os::raw::c_char,
        data: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_uint64(
        name: *const ::std::os::raw::c_char,
        data: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_quad(
        name: *const ::std::os::raw::c_char,
        data: *mut quad_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_setenv(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_unsetenv(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn testenv(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_array(
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        psize: *mut ::std::os::raw::c_int,
        type_size: ::std::os::raw::c_int,
        allow_signed: bool_,
    ) -> ::std::os::raw::c_int;
}
pub type cpu_tick_f = ::std::option::Option<unsafe extern "C" fn() -> u64>;
extern "C" {
    pub fn set_cputicker(func: cpu_tick_f, freq: u64, var: ::std::os::raw::c_uint);
}
extern "C" {
    pub static mut cpu_ticks: cpu_tick_f;
}
extern "C" {
    pub fn cpu_tickrate() -> u64;
}
extern "C" {
    pub fn cputick2usec(tick: u64) -> u64;
}
extern "C" {
    pub static mut bcd2bin_data: [u_char; 0usize];
}
extern "C" {
    pub static mut bin2bcd_data: [u_char; 0usize];
}
extern "C" {
    pub static mut hex2ascii_data: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut arc4rand_iniseed_state: ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
}
extern "C" {
    pub fn arc4rand(arg1: *mut ::std::os::raw::c_void, arg2: u_int, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: size_t,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn fnmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn locc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: u_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        s: *const ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcchr(
        s: *const ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmem(
        l: *const ::std::os::raw::c_void,
        l_len: size_t,
        s: *const ::std::os::raw::c_void,
        s_len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        base: *mut ::std::os::raw::c_void,
        nmemb: size_t,
        size: size_t,
        compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_r(
        base: *mut ::std::os::raw::c_void,
        nmemb: size_t,
        size: size_t,
        thunk: *mut ::std::os::raw::c_void,
        compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn random() -> u_long;
}
extern "C" {
    pub fn scanc(
        arg1: u_int,
        arg2: *const u_char,
        arg3: *const u_char,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strdup_flags(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut malloc_type,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strdup(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut malloc_type,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *mut malloc_type,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strvalid(arg1: *const ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn consinit();
}
extern "C" {
    pub fn cpu_initclocks();
}
extern "C" {
    pub fn cpu_initclocks_bsp();
}
extern "C" {
    pub fn cpu_initclocks_ap();
}
extern "C" {
    pub fn usrinfoinit();
}
extern "C" {
    pub fn kern_reboot(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn shutdown_nice(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _sleep(
        chan: *const ::std::os::raw::c_void,
        lock: *mut lock_object,
        pri: ::std::os::raw::c_int,
        wmesg: *const ::std::os::raw::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msleep_spin_sbt(
        chan: *const ::std::os::raw::c_void,
        mtx: *mut mtx,
        wmesg: *const ::std::os::raw::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause_sbt(
        wmesg: *const ::std::os::raw::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wakeup(chan: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn wakeup_one(chan: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn wakeup_any(chan: *const ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn dev2udev(x: *mut cdev) -> dev_t;
}
extern "C" {
    pub fn devtoname(cdev: *mut cdev) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn devfs_iosize_max() -> size_t;
}
extern "C" {
    pub fn iosize_max() -> size_t;
}
extern "C" {
    pub fn poll_no_poll(events: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DELAY(usec: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token {
    pub flags: ::std::os::raw::c_int,
    pub who: *const ::std::os::raw::c_char,
    pub list: root_hold_token__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token__bindgen_ty_1 {
    pub tqe_next: *mut root_hold_token,
    pub tqe_prev: *mut *mut root_hold_token,
}
#[test]
fn bindgen_test_layout_root_hold_token__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<root_hold_token__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(root_hold_token__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<root_hold_token__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(root_hold_token__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<root_hold_token__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<root_hold_token__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_root_hold_token() {
    assert_eq!(
        ::std::mem::size_of::<root_hold_token>(),
        32usize,
        concat!("Size of: ", stringify!(root_hold_token))
    );
    assert_eq!(
        ::std::mem::align_of::<root_hold_token>(),
        8usize,
        concat!("Alignment of ", stringify!(root_hold_token))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<root_hold_token>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<root_hold_token>())).who as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token),
            "::",
            stringify!(who)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<root_hold_token>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token),
            "::",
            stringify!(list)
        )
    );
}
extern "C" {
    pub fn root_mount_hold(identifier: *const ::std::os::raw::c_char) -> *mut root_hold_token;
}
extern "C" {
    pub fn root_mount_hold_token(
        identifier: *const ::std::os::raw::c_char,
        h: *mut root_hold_token,
    );
}
extern "C" {
    pub fn root_mount_rel(h: *mut root_hold_token);
}
extern "C" {
    pub fn root_mounted() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn new_unrhdr(
        low: ::std::os::raw::c_int,
        high: ::std::os::raw::c_int,
        mutex: *mut mtx,
    ) -> *mut unrhdr;
}
extern "C" {
    pub fn init_unrhdr(
        uh: *mut unrhdr,
        low: ::std::os::raw::c_int,
        high: ::std::os::raw::c_int,
        mutex: *mut mtx,
    );
}
extern "C" {
    pub fn delete_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clear_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdrl(uh: *mut unrhdr);
}
extern "C" {
    pub fn alloc_unr(uh: *mut unrhdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alloc_unrl(uh: *mut unrhdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr64 {
    pub counter: u64,
}
#[test]
fn bindgen_test_layout_unrhdr64() {
    assert_eq!(
        ::std::mem::size_of::<unrhdr64>(),
        8usize,
        concat!("Size of: ", stringify!(unrhdr64))
    );
    assert_eq!(
        ::std::mem::align_of::<unrhdr64>(),
        8usize,
        concat!("Alignment of ", stringify!(unrhdr64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unrhdr64>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unrhdr64),
            "::",
            stringify!(counter)
        )
    );
}
extern "C" {
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
}
extern "C" {
    pub fn counted_warning(
        counter: *mut ::std::os::raw::c_uint,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _gone_in(major: ::std::os::raw::c_int, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _gone_in_dev(
        dev: *mut device,
        major: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type_stats {
    pub mts_memalloced: u64,
    pub mts_memfreed: u64,
    pub mts_numallocs: u64,
    pub mts_numfrees: u64,
    pub mts_size: u64,
    pub _mts_reserved1: u64,
    pub _mts_reserved2: u64,
    pub _mts_reserved3: u64,
}
#[test]
fn bindgen_test_layout_malloc_type_stats() {
    assert_eq!(
        ::std::mem::size_of::<malloc_type_stats>(),
        64usize,
        concat!("Size of: ", stringify!(malloc_type_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<malloc_type_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_type_stats))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<malloc_type_stats>())).mts_memalloced as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_memalloced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type_stats>())).mts_memfreed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_memfreed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type_stats>())).mts_numallocs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_numallocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type_stats>())).mts_numfrees as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_numfrees)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type_stats>())).mts_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<malloc_type_stats>()))._mts_reserved1 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(_mts_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<malloc_type_stats>()))._mts_reserved2 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(_mts_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<malloc_type_stats>()))._mts_reserved3 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(_mts_reserved3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type_internal {
    pub mti_probes: [u32; 2usize],
    pub mti_zone: u_char,
    pub mti_stats: *mut malloc_type_stats,
}
#[test]
fn bindgen_test_layout_malloc_type_internal() {
    assert_eq!(
        ::std::mem::size_of::<malloc_type_internal>(),
        24usize,
        concat!("Size of: ", stringify!(malloc_type_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<malloc_type_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_type_internal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type_internal>())).mti_probes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_internal),
            "::",
            stringify!(mti_probes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type_internal>())).mti_zone as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_internal),
            "::",
            stringify!(mti_zone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type_internal>())).mti_stats as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_internal),
            "::",
            stringify!(mti_stats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type {
    pub ks_next: *mut malloc_type,
    pub ks_magic: u_long,
    pub ks_shortdesc: *const ::std::os::raw::c_char,
    pub ks_handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_malloc_type() {
    assert_eq!(
        ::std::mem::size_of::<malloc_type>(),
        32usize,
        concat!("Size of: ", stringify!(malloc_type))
    );
    assert_eq!(
        ::std::mem::align_of::<malloc_type>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type>())).ks_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type),
            "::",
            stringify!(ks_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type>())).ks_magic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type),
            "::",
            stringify!(ks_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type>())).ks_shortdesc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type),
            "::",
            stringify!(ks_shortdesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type>())).ks_handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type),
            "::",
            stringify!(ks_handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type_stream_header {
    pub mtsh_version: u32,
    pub mtsh_maxcpus: u32,
    pub mtsh_count: u32,
    pub _mtsh_pad: u32,
}
#[test]
fn bindgen_test_layout_malloc_type_stream_header() {
    assert_eq!(
        ::std::mem::size_of::<malloc_type_stream_header>(),
        16usize,
        concat!("Size of: ", stringify!(malloc_type_stream_header))
    );
    assert_eq!(
        ::std::mem::align_of::<malloc_type_stream_header>(),
        4usize,
        concat!("Alignment of ", stringify!(malloc_type_stream_header))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<malloc_type_stream_header>())).mtsh_version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stream_header),
            "::",
            stringify!(mtsh_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<malloc_type_stream_header>())).mtsh_maxcpus as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stream_header),
            "::",
            stringify!(mtsh_maxcpus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<malloc_type_stream_header>())).mtsh_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stream_header),
            "::",
            stringify!(mtsh_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<malloc_type_stream_header>()))._mtsh_pad as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stream_header),
            "::",
            stringify!(_mtsh_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type_header {
    pub mth_name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_malloc_type_header() {
    assert_eq!(
        ::std::mem::size_of::<malloc_type_header>(),
        32usize,
        concat!("Size of: ", stringify!(malloc_type_header))
    );
    assert_eq!(
        ::std::mem::align_of::<malloc_type_header>(),
        1usize,
        concat!("Alignment of ", stringify!(malloc_type_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_type_header>())).mth_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_header),
            "::",
            stringify!(mth_name)
        )
    );
}
extern "C" {
    pub static mut M_CACHE: [malloc_type; 1usize];
}
extern "C" {
    pub static mut M_DEVBUF: [malloc_type; 1usize];
}
extern "C" {
    pub static mut M_TEMP: [malloc_type; 1usize];
}
extern "C" {
    pub static mut M_IOV: [malloc_type; 1usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct domainset {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut malloc_mtx: mtx;
}
pub type malloc_type_list_func_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut malloc_type, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn contigfree(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
        type_: *mut malloc_type,
    );
}
extern "C" {
    pub fn contigmalloc(
        size: ::std::os::raw::c_ulong,
        type_: *mut malloc_type,
        flags: ::std::os::raw::c_int,
        low: vm_paddr_t,
        high: vm_paddr_t,
        alignment: ::std::os::raw::c_ulong,
        boundary: vm_paddr_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn contigmalloc_domainset(
        size: ::std::os::raw::c_ulong,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::std::os::raw::c_int,
        low: vm_paddr_t,
        high: vm_paddr_t,
        alignment: ::std::os::raw::c_ulong,
        boundary: vm_paddr_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(addr: *mut ::std::os::raw::c_void, type_: *mut malloc_type);
}
extern "C" {
    pub fn zfree(addr: *mut ::std::os::raw::c_void, type_: *mut malloc_type);
}
extern "C" {
    pub fn free_domain(addr: *mut ::std::os::raw::c_void, type_: *mut malloc_type);
}
extern "C" {
    pub fn malloc(
        size: size_t,
        type_: *mut malloc_type,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_domainset(
        size: size_t,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mallocarray(
        nmemb: size_t,
        size: size_t,
        type_: *mut malloc_type,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_init(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc_last_fail() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc_type_allocated(type_: *mut malloc_type, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_freed(type_: *mut malloc_type, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_list(arg1: malloc_type_list_func_t, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc_uninit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        addr: *mut ::std::os::raw::c_void,
        size: size_t,
        type_: *mut malloc_type,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(
        addr: *mut ::std::os::raw::c_void,
        size: size_t,
        type_: *mut malloc_type,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_desc2type(desc: *const ::std::os::raw::c_char) -> *mut malloc_type;
}
pub type __builtin_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list {
    pub __stack: *mut ::std::os::raw::c_void,
    pub __gr_top: *mut ::std::os::raw::c_void,
    pub __vr_top: *mut ::std::os::raw::c_void,
    pub __gr_offs: ::std::os::raw::c_int,
    pub __vr_offs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___va_list() {
    assert_eq!(
        ::std::mem::size_of::<__va_list>(),
        32usize,
        concat!("Size of: ", stringify!(__va_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list>())).__stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list>())).__gr_top as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__gr_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list>())).__vr_top as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__vr_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list>())).__gr_offs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__gr_offs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list>())).__vr_offs as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__vr_offs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct witness {
    pub _address: u8,
}
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_list_entry {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmap {
    pub _address: u8,
}
